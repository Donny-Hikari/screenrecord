#!/bin/bash

# AUTHOR: Donny (c) 2018
# NAME: ScreenRecord 0.1.5
# DESCRIPTION:  A shell script for recording screen under linux.
# DEPENDENCIES:   ffmpeg, notify-send (optional)

# App name, display when pushing notification
APPNAME="ScreenRecord"
# Video2gif script location
video2gif="bash $(dirname $(readlink -f $0))/video2gif"

ERR_NONE=0
ERR_UNRECOGNIZED_PARAMETERS=1
ERR_MISSING_PARAMETERS=2
ERR_OPERATION_FAILED=3

HELP_HINT="Try -h or --help to get help infomation."

# Whether to display ui notification or not
UINOTIFY=1
# Delay before starting
DELAY=3
# Recording duration; default: 0 - keep recording until user press 'q'
DURATION=0
# Recording frame rate
FRAMERATE=30
# Recording scale
SCALE=-1:-1
# Time and date
TIME=$(date +"%Y-%m-%d_%H-%M-%S")
# Default output filename
DEFNAME=ScreenRecord_$TIME.mp4
# Output filename
OUTPUTNAME=$HOME/Pictures/$DEFNAME
# Whether to output video file or not.
# If both $OUTPUTVIDEO and $OUTPUTGIF are zeros, a video will be outputed by default.
OUTPUTVIDEO=0
# Whether to output gif file or not
OUTPUTGIF=0
# Options placed before in stream when recording; default: None
INOPTIONS=
# Options placed before out stream when recording; default: None
OUTOPTIONS=
# Capture mode, one of "window"|"screen"|WxH+X+Y; default: "window"
CAPTUREMODE="window"
# Preview the settings only. Not doing actual recording
PREVIEWONLY=0

# Recoding geometry
X=0
Y=0
W=0
H=0

print_info() {
    echo ""
    echo "ScreenRecord - Record screen to video or gif file"
    echo "Author: Donny (c) 2018"
    echo "Version: 0.1.5"
    echo ""
}

print_usage() {
    PRINT_FORMAT="%-26s%s\n"

    echo "Usage: $(basename $0) [OPTIONS]"
    
    echo ""
    echo "Help options:"
    printf $PRINT_FORMAT "-h|--help"    "Print help options"

    echo ""
    echo "Behaviors options:"
    printf $PRINT_FORMAT "--delay number"            "delay \"number\" seconds before recording"
    printf $PRINT_FORMAT "-m|--capture-mode mode"    "set the capture mode; one of \"window\"|\"screen\"|WxH+X+Y; default: \"Window\""
    printf $PRINT_FORMAT "--noui"                    "suppress ui output, which means not using notify-send"
    printf $PRINT_FORMAT "--preview"                 "preview the parameters only, not doing actual recording"

    echo ""
    echo "Recording options:"
    printf $PRINT_FORMAT "-o|--output filename"     "set the output filename; if not extension specified, a mp4 format video will be produced"
    printf $PRINT_FORMAT "-d|--duration number"     "record \"number\" seconds of video/gif; 0 means keep recording until user press 'q'"
    printf $PRINT_FORMAT "-f|--framerate number"    "set the recording frame rate"
    printf $PRINT_FORMAT "-s|scale widthxheight"    "scale the recording output to widthxheight"
    printf $PRINT_FORMAT "--gif"                    "output gif"
    printf $PRINT_FORMAT "--video"                  "output video; by default a video will be produced if neither --gif nor --video option is given"
    printf $PRINT_FORMAT "--options-in"             "set options placed before ffmpeg input stream when recording"
    printf $PRINT_FORMAT "--options-out"            "set options placed before ffmpeg output stream when recording"

    echo ""
    return
}

print_variables() {
    echo "====== PREVIEW PARAMETERS ======"
    echo "Delay: $DELAY"
    echo "Capture Mode: $CAPTUREMODE"
    echo "UI Notify: $UINOTIFY"
    echo "Preview: $PREVIEWONLY"
    echo ""
    echo "Output Filename: \"$OUTPUTNAME\""
    echo "Duration: $DURATION"
    echo "Framerate: $FRAMERATE"
    echo "Scale: $SCALE"
    echo "Output Gif: $OUTPUTGIF"
    echo "Output Video: $OUTPUTVIDEO"
    echo "In Options: $INOPTIONS"
    echo "Out Options: $OUTOPTIONS"
    echo ""
    echo "Recoding Geometry: ${W}x${H}+${X}+${Y} (WxH+X+Y)"
    echo ""
}

# Sound notification to let one know when recording is about to start (and ends)
beep() {
    paplay /usr/share/sounds/freedesktop/stereo/message-new-instant.oga &
}

# Text notification in both console and ui notification.
notify() {
    msg=$1; echo $msg;
    if [[ $UINOTIFY -eq 1 ]]; then
        notify-send $APPNAME "$msg"
    fi
}

print_info

# Translate arguments
ALLARGUMENTS=()
while [[ $# -gt 0 ]]
do
    key=$1; ALLARGUMENTS+=($1); shift;
    case $key in
        # HELP OPTIONS
        -h|--help)
        print_usage
        exit $ERR_NONE
        ;;

        # BEHAVIORS OPTIONS
        --delay)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ $next -ge 0 ]]; then
            DELAY=$next
        fi
        ;;
        -m|--capture-mode)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ -z $next ]]; then
            echo "--capture-mode parameter missing"
            echo $HELP_HINT
            exit $ERR_MISSING_PARAMETERS
        else
            CAPTUREMODE=$next
        fi
        ;;
        --noui)
        UINOTIFY=0
        ;;
        --preview)
        PREVIEWONLY=1
        ;;

        # RECORDING OPTIONS
        -o|--output)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ -z $next ]]; then
            echo "--output filename missing."
            echo $HELP_HINT
            exit $ERR_MISSING_PARAMETERS
        else
            OUTPUTNAME=$next
            # If not filename given, use the $DEFNAME
            filename=${OUTPUTNAME##*/}
            if [[ -z $filename ]]; then
                OUTPUTNAME=${OUTPUTNAME}${DEFNAME}
            fi
        fi
        ;;
        -d|--duration)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ $next -gt 0 ]]; then
            DURATION=$next
        fi
        ;;
        -f|--framerate)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ $next -gt 0 ]]; then
            FRAMERATE=$next
        fi
        ;;
        -s|--scale)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ -z $next ]]; then
            echo "--scale parameter missing."
            echo $HELP_HINT
            exit $ERR_MISSING_PARAMETERS
        else
            SCALE=$next
        fi
        ;;
        --gif)
        OUTPUTGIF=1
        ;;
        --video)
        OUTPUTVIDEO=1
        ;;
        --options-in)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ -z $next ]]; then
            echo "--options-in parameter missing."
            echo $HELP_HINT
            exit $ERR_MISSING_PARAMETERS
        else
            INOPTIONS=$next
        fi
        ;;
        --options-out)
        next=$1; ALLARGUMENTS+=($1); shift;
        if [[ -z $next ]]; then
            echo "--options-out parameter missing."
            echo $HELP_HINT
            exit $ERR_MISSING_PARAMETERS
        else
            OUTOPTIONS=$next
        fi
        ;;
        *)
        echo "Unrecognized parameter: $key."
        echo $HELP_HINT        
        exit $ERR_UNRECOGNIZED_PARAMETERS
        ;;
    esac
done
set -- "${ALLARGUMENTS[@]}" # restore arguments

fileext=${OUTPUTNAME##*.}; if [[ "$fileext" == $OUTPUTNAME ]]; then fileext=""; fi
if [[ -z $fileext ]]; then
    if [[ $OUTPUTGIF -eq 1 ]] && [[ $OUTPUTVIDEO -eq 0 ]]; then
        OUTPUTNAME+=".gif"
    else
        OUTPUTNAME+=".mp4"
        OUTPUTVIDEO=1 # Output video by default
    fi
elif [[ "$fileext" == "gif" ]]; then
    OUTPUTGIF=1
    if [[ $OUTPUTVIDEO -eq 1 ]]; then
        OUTPUTNAME=${OUTPUTNAME%.*}.mp4
    fi
else
    OUTPUTVIDEO=1 # Output video by default
fi
# End translate arguments

# Determine capture mode
case $CAPTUREMODE in
    "Window"|"window")
    # Window geometry
    echo "Please select the window you'd like to record by clicking the mouse in that window."
    echo ""
    XWININFO=$(xwininfo)
    read X < <(awk -F: '/Absolute upper-left X/{print $2}' <<< "$XWININFO")
    read Y < <(awk -F: '/Absolute upper-left Y/{print $2}' <<< "$XWININFO")
    read W < <(awk -F: '/Width/{print $2}' <<< "$XWININFO")
    read H < <(awk -F: '/Height/{print $2}' <<< "$XWININFO")
    ;;
    "Screen"|"screen")
    XRANDR=$(xrandr)
    X=0; Y=0
    read RESOLUTION < <(grep -Eo 'current [[:digit:]]+ x [[:digit:]]+' <<< "$XRANDR")
    read W < <(grep -Eo '[[:digit:]]+' <<< "$RESOLUTION" | sed -n '1p')
    read H < <(grep -Eo '[[:digit:]]+' <<< "$RESOLUTION" | sed -n '2p')
    ;;
    *)
    read X < <(grep -Eo '[[:digit:]]+' <<< "$CAPTUREMODE" | sed -n '3p')
    read Y < <(grep -Eo '[[:digit:]]+' <<< "$CAPTUREMODE" | sed -n '4p')
    read W < <(grep -Eo '[[:digit:]]+' <<< "$CAPTUREMODE" | sed -n '1p')
    read H < <(grep -Eo '[[:digit:]]+' <<< "$CAPTUREMODE" | sed -n '2p')
    ;;
esac

# Preview parameters only
if [[ $PREVIEWONLY -eq 1 ]]; then
    print_variables
    exit $ERR_NONE
fi

if [[ $DURATION -eq 0 ]]; then
    DURATION=
else
    DURATION="-t $DURATION"
fi

# Check file existance
if [[ -f $OUTPUTNAME ]]; then
    printf "File \"$OUTPUTNAME\" already exists. Override? [y/n]"
    read k
    if [[ "$k" != 'y' ]] && [[ "$k" != 'Y' ]]; then
        exit $ERR_NONE
    else
        rm $OUTPUTNAME
        if [[ $? -ne 0 ]]; then
            echo "Fail to override file \"$OUTPUTNAME\"."
            exit $ERR_OPERATION_FAILED
        fi
    fi
fi

# Notify the user of recording delay
notify "Recording will start in $DELAY seconds."
echo ""

# Actual recording
sleep $DELAY
beep
ffmpeg -video_size ${W}x${H} -framerate $FRAMERATE -f x11grab $INOPTIONS -i :0.0+${X},${Y} $DURATION -vf "scale=$SCALE" $OUTOPTIONS "$OUTPUTNAME"
result=$?
beep

if [[ $result -ne 0 ]]; then
    notify "Screen record of $OUTPUTNAME failed."
    exit $ERR_OPERATION_FAILED
fi

# Convert to gif
if [[ $OUTPUTGIF -eq 1 ]] && [[ $OUTPUTVIDEO -eq 1 ]]; then
    $video2gif $OUTPUTNAME
fi

# Notify the user of end of recording.
notify "Screen record saved to $OUTPUTNAME"

exit $ERR_NONE
